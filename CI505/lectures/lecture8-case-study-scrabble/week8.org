* Introduction to Functional Programming

#+BEGIN_center  
#+ATTR_ORG: :width 800
[[../common/images/logo7000.png]] 
#+END_center

* Scrabble: Developing software in Haskell

#+BEGIN_center  
#+ATTR_ORG: :width 800
[[../common/images/scrabble.jpeg]] 
#+END_center
* Getting started

  This lecture and the ones that follow it are based on the repository
  https://github.com/jimburton/scrabble.

  This repository contains a one- or two-player implementation of the
  *Scrabble* boardgame.

  The emphasis is not so much on how to implement scrabble but on
  developing a Haskell project with several parts and a decent amount
  of code.

* Getting started

  We produce a library that knows how to play the game (including an
  AI player) and is able to run on a server, fully decoupled from
  clients with which it communicates over the network using JSON.

#+BEGIN_center  
#+ATTR_ORG: :width 800
[[./images/webgame.png]] 
#+END_center

* Getting started

Commonly used data structures and libraries like ~Data.Text~, /maps/,
/arrays/, /aeson/ and /lens/ are explained, as well as /monadic error
checking/ and building a WebSocket client to the game that shows how
to use /threads/ and other concurrency abstractions safely.

Each chapter refines the initial solution, ending up with something
that is (hopefully) a clean, functional design that can easily be
extended.

* Where are we now?

So far, you have learned the basics of Haskell:

+ written lots of (small) functions, 
+ learned about recursion, folds, etc,
+ practised some ~IO~ and heard about typeclasses like ~Functor~
  and ~Monad~,
+ used ~cabal~ a little bit.
    
* The next steps

There is a notoriously *big gap* between learning the basics listed
above, which mostly means a lot of fiddling about with lists, and
finding yourself making useful, nicely written and idiomatic
software with Haskell.

For beginners the language can seem academic and far removed from
the tasks we normally want to achieve with programming languages.

When they look at Haskell code in the wild it bears little
resemblance to their exercises.

* The next steps

The Scrabble project is meant to go some way towards filling that
gap.

By the end you'll have been introduced to some major and widely used
libraries, sophisticated data structures, functional design
patterns, and means for structuring a Haskell project so that you
can keep on top of it as it grows.

I won't say it will take you from being a beginner-level to an
intermediate-level Haskell programmer;

Haskell is a deep language and if /Intermediate/ is halfway between
/Beginner/ and /Expert/ then that's a bit of a stretch.  But you won't
be a beginner any more.

* The repository

The repository is structured as a book in 8 chapters.

We won't have time to go through all of them in detail, but you can
do this as independent learning.

There is a branch in the repository for each chapter, named
~chapter1~, ~chapter2~, etc, up to ~chapter7~.

As you read each chapter you should check out the corresponding
branch and study the code.

There are exercises at the end of each chapter which expect you to be
working on the code from the right branch.

* Managing the code

We're using ~cabal~ to manage the project.

~cabal~ deals in /libraries/ and /executables/.

We will eventually be making several executables but the core code
for playing the game is contained in a library stanza.

As such, there isn't an entry point or any way for users to run the
code. It is there for ourselves and others to import into code that
*does* provide an interface for users.

*Demo:* ~scrabble.cabal~

* Building blocks

When you start writing any software you need to think about
modelling the problem in hand.

When we think of a game of Scrabble we can immediately anticipate
that we'll need to handle:

+ a *board*,
+ a number of *tiles*,
+ several *racks* containing tiles, and
+ a *bag*, also containing tiles.

* Building blocks

We also need to account for some things that we can't see:
+ the *game* itself, which consists of the objects mentioned plus
+ several *players*,
+ some additional state (e.g. whose *turn* it is).
+ the *score* of each player,
+ the *rules* of the game,
+ a *dictionary*.

* Letters and tiles

#+BEGIN_center  
#+ATTR_ORG: :width 800
[[images/tile.jpg]]
#+END_center

A tile consists of a *letter* and a *value*. We could create a
type alias such as

#+BEGIN_SRC haskell
type Tile = (Char,Int) 
#+END_SRC

* Letters and tiles

But then the type system wouldn't be able to rule out nonsense
values like ~('Â£',0)~, we might find ourselves needing to
distinguish between 'a' and 'A', and so on.

So we create an enumeration of all possible letters and make the
datatype derive some useful typeclasses:

#+BEGIN_SRC haskell
-- | Letters.  data Letter = A | B | C ... Z | Blank deriving (Show,
Read, Enum, Eq, Ord)
-- | A tile is a pair of a letter and a value.  type Tile =
(Letter,Int) 
#+END_SRC

* Letters and tiles

We will need to know a number of things about letters:

+ the score of each letter,
+ how many tiles bearing each letter should be in a full bag, and
+ the ~Char~ value for printing.

* Letters and tiles

We will store this data in \emph{maps}, using the \texttt{Data.Map}
API.

We could use a simple list of pairs with the type ~[(Letter,Int)]~
but maps are much more efficient (O(log n)) lookup tables.

Because it contains many functions whose names clash with those of
functions in the ~Prelude~, like ~filter~ and ~map~, this is
normally imported with a qualified name.

#+BEGIN_SRC haskell
  import           Data.Map (Map)
  import qualified Data.Map as M
#+END_SRC

* The board

A Scrabble board is a 15x15 matrix of rows and columns, so a natural
way to model it is as a two-dimensional array.

The values stored in the array will be ~Maybe Tile~ values
(i.e. either ~Nothing~ for an empty square, or something like ~Just
(A,1)~ for a square with an 'A' tile on it).

* The board

In many languages we would create an array of arrays to achieve
this, where each element of the 15-element outer array is a
15-element array representing a row.

However, Haskell supports true multi-dimensional arrays, so we can
create one where the type of indices is ~(Int,Int)~ (for our
purpose, ~(row,column)~).

#+BEGIN_SRC haskell
-- in Scrabble.Types
import Data.Array
-- | The board, a 2D array of Maybe letters and their scores.  type
Board = Array (Int,Int) (Maybe Tile) 
#+END_SRC

* The board

Then, if we have a board called ~b~ we can access the value in row
~r~, column ~c~, by ~b ! (r,c)~.

These ~(r,c)~ pairs are going to be used a lot so we make a type for
those too.

#+BEGIN_SRC haskell
-- | A position on the board.  type Pos = (Int,Int) 
#+END_SRC

* Words

/Words/, /racks/ and /bags/ are all just lists of letters, but it's
helpful to distinguish between them in type signatures so we make
aliases for each of them.

Because the ~Prelude~ includes a type called ~Word~ we have a name
clash here.

We could call our new type ~ScrabbleWord~ or something like that,
but it seems more convenient to keep the short name and hide the
type in the ~Prelude~, which we don't need anyway.

#+BEGIN_SRC haskell
import Prelude hiding (Word)
#+END_SRC

* Words on the board
A word we want to place on the board is a list of pairs of ~Pos~ and
~Tile~ values.

We'll call this a ~WordPut~.

#+BEGIN_SRC haskell
-- | A word placed on the board (tiles plus positions).  type WordPut
= [(Pos, Tile)] 
#+END_SRC

* Bonus squares

Last up for the board are the /bonus squares/.
These are either double or triple word bonuses, or double or triple
letter bonuses.

We make a datatype for bonuses and a map of their positions.
We will put everything other than the type for bonuses in its own
module to keep things tidy.

*Demo:* ~Scrabble.Types~ and ~Scrabble.Bonus~

* The dictionary

A copy of the standard English Scrabble dictionary as a text file
with one word per line is stored at ~dict/en.txt~.

It is a pretty big file, with more than *260,000* entries.

Obviously we need to store this in a data structure which is as
efficient as possible, especially when it comes to being searched.

* The dictionary

If we only ever wanted to look up words to see if they exist then a
/hashtable/ would be the best choice, with search taking O(1)
time.

However, we want to search in more flexible ways than this.

We are going to build a computer player at some point, so we might
want to find all words that can be made based on a collection of
letters, words that include existing tiles on the board, all words
that are prefixes of some other word and so on.

* The dictionary

There are several data structures that store words (or any sequence
of values) in ways that allow prefixes to be shared.

This not only saves a lot of space but allows the flexibility in
searching that we need.

The /trie/ [1] allows us to find a word and all of its prefixes very
quickly (in O(m) time, where /m/ is the length of the word --
i.e. independently of /n/, the size of the dictionary).

[1] https://en.wikipedia.org/wiki/Trie

* The trie

Here is an illustration of a trie storing the words /their/,
/there/, /answer/, /any/ and /bye/.

     root
    /  |  \
    t  a   b
    |  |   |
    h  n   y
    |  |\  |
    e  s y e
   /|  |
  i r  w
  | |  |
  r e  e
       |
       r
      
* The dictionary

We don't actually care what is stored at the leaves of the trie, as
we only need to know which paths in the trie exist.

So in each leaf we just store () ("unit"), which is the type with
exactly one value in it (also called (), "unit").

*Demo:* ~Scrabble.Types~ and ~Scrabble.Dict~

* Putting a word on the board

To create the initial empty board we can use the ~array~ function to
turn a list of pairs of indices and ~Nothing~ values into a 15x15
array.

Then we can put a ~WordPut~ onto the board.

The ~updateBoard~ function uses a fold to update the array with each
element of the ~WordPut~ in turn. The ~(//)~ operator is used in
~updateSquare~ to update the array.

*Demo:* ~Scrabble.Board~

* Retrieving a word from the board}

We can check whether a position on the board is occupied by a tile
with the functions ~onBoard~ and ~getSquare~ in ~Scrabble.Board~.

See also the ~Dir~ type and ~getDirection~.

* Retrieving a word from the board

Given an occupied position, if we know the direction we can find the
beginning of the ~WordPut~ it is part of.

Given the start of a ~WordPut~ we can retrieve the whole thing.
See ~Scrabble.Board~ and the functions ~wordOnRow~ and ~wordOnCol~.

*Demo* of querying board in ghci.

* Pretty-printing boards

We want a function that turns a board into text that looks something
remotely like a Scrabble board.

See ~Scrabble.Pretty~.

*Demo* of adding a word to the board and printing it.

* Testing

We need to think about what we want to be always true about the
types and functions we have created.

We use the ~QuickCheck~ library for property-based testing.
This means that we specify some property that we want our functions
to have and the library generates arbitrary input that checks
whether the property holds.

* Testing

The ~test-suite~ stanza in the config file deptermines what tests
should be run and how.

It points to the file ~tests/Main.hs~ as the entry point.

Run the tests with ~cabal run test-scrabble~.

* Testing

To test functions relating to boards we need to be able to generate
arbitrary values of ~Pos~, ~Letter~, ~WordPut~ and so on.

We write generators that use the ~QuickCheck~ library to do that in
~Test.Gen~.

*Demo:* ~Test.Gen~ and ~Test.Chapter1~

* Exercises

Have a go at the exercises at the end of Chapter 1!

* Players and the game

Now we can move on to think about /players/ and the /game/ itself.

A player has a /name/, a /rack/, a /score/ and might be an /AI/
player.

A game will have two players, a /board/, a /StdGen/ for
pseudo-randomness requirements, and several Boolean fields to keep
track of the progress of the game.

Most of this code is going into a new module, ~Scrabble.Game~.

* Players and the game

We introduce two record types, /Player/ and /Game/.

They embody everything we need to know to manage the state of games.

The types themselves are simple but we need to take a bit of a
digression to explain the way we will working with them.

*Demo:* ~Scrabble.Types~

* ~Data.Text~

The name of each player is stored as ~Data.Text~ rather than
~String~.

Wherever possible, when we need to store some text we will use the
~Text~ datatype instead of ~String~.

This is because ~String~, being a simple linked list, is very
inefficient.

Like ~Data.Map~, it is usual practice to import ~Data.Text~ with a
qualified name, apart from the name of the type itself which is
imported directly for convenience.

* ~Data.Text~

To make working with ~Text~ values easier, we turn on the
~OverloadedStrings~ extension in our code.

This means that any literal strings in our code are treated as
~Text~.

The extension is turned on in the ~cabal~ config file and by
including a "language pragma" (an instruction to the compiler) at
the top of any files that need it:

#+BEGIN_SRC haskell
{-# LANGUAGE OverloadedStrings #-} 
#+END_SRC

* Records, their clumsiness, and lenses

As the ~Player~ and ~Game~ datatypes are records we can create them
with named fields and update them by assigning those fields inside
braces.

The compiler creates an accessor function for each field with the same
name as the field.

#+BEGIN_SRC haskell
> let p = Player { _name = "Bob", _rack = [A, B, C, D, E, F, G],
> _score = 0} _name p "Bob" p { _name = "Alice", _score = 42 }
> Player { _name = "Alice" , _rack = [ A , B , C , D , E , F , G ] ,
> _score = 42 } 
#+END_SRC

* Records, their clumsiness, and lenses

Our main record will be ~Game~ and it has two ~Player~ values nested
within it.

As soon as we need to update values in this structure we encounter a
well-known problem -- the syntax for records makes this awkward.

Let's say we have a game called =g= and we want to increase
the score of Player 1 by 10:

#+BEGIN_SRC haskell
> let g' = g { _player1 = ( _player1 g) { _score = _score (
_player1 g) + 10 } } 
#+END_SRC

* Records, their clumsiness, and lenses

Oof!

Haskell is meant to be elegant...considering that in an OO language
we could probably do something like ~p.player1.score += 10~, this is
very cumbersome.

This is the problem that /lenses/ overcome.

Lenses are /first class getters and setters/ for records.

They can be composed, so they allow us to access and modify values
that are deeply nested in data, like the ~_score~ field above.

* Lenses

This isn't the place for an in-depth lens tutorial, and I'm hoping
to tell you just enough about them to understand the way they're
used in this project, which is very basic.

It's highly recommended that you do read such a tutorial eventually,
such as the standard one:

http://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html

* Lenses

Each lens comes with two main functions: ~view~, which gives the
value of the field, and ~over~, which modifies its value.

Rather than using these functions by name we most often use one of
the lens operators.

If we define lenses for ~Player~ and ~Game~ and use one of the
standard lens librarys, we can rewrite the the code above like this:

#+BEGIN_SRC haskell
> let g' = g & player1 . score %~ (+10) g' ^. (player1 . score) 52
> 
#+END_SRC

* Lenses

As we can see from the differences in their names, \texttt{score}
and \texttt{player1} are not the accessor functions we saw before.

They are lenses.

Given a record, ~p~, with a field, ~score~, we can get the value of
~score~ with

#+BEGIN_SRC haskell
p ^. score 
#+END_SRC

* Lenses

We can set =score= to a new value, ~x~, with

#+BEGIN_SRC haskell
p & score .~ x 
#+END_SRC

and update its value by applying a function to it:

#+BEGIN_SRC haskell
p & score %~ foo 
#+END_SRC

* Lenses

The ~(&)~ operator is like ~($)~ but it takes its arguments in
reverse order, so our original lens function,

#+BEGIN_SRC haskell
g' = g & player1 . score %~ (+10) 
#+END_SRC

is the same as writing

#+BEGIN_SRC haskell
g' = (player1 . score %~ (+10)) g 
#+END_SRC

* Lenses

#+BEGIN_SRC haskell
(player1 . score %~ (+10)) g 
#+END_SRC

In the above ~g~ is applied to a function which is a lens made up of
~player1~ and ~score~ composed with the usual composition operator,
~(.)~.

Then comes the =(%~)= operator, which takes a lens as its
first argument and a function as its second, and supplies the value
from the lens to the function.

Haskell is still a purely functional language of course, so no change
is made to ~g~, but a new ~Game~ record is produced which we assign to
=g'=.

* Lenses

Lenses can be used to access the value of the field or to "change"
it.

Which purpose the lens serves depends on the context, which is set
by the lens operators involved.

For example, ~player1~ acts like a getter in

#+BEGIN_SRC haskell
g ^. player1 
#+END_SRC

It acts like a setter in

#+BEGIN_SRC haskell
g & player1 .~ p 
#+END_SRC

* Lenses

The ~(&)~ operator has a very simple type,

#+BEGIN_SRC haskell
(&) :: a -> (a -> b) -> b 
#+END_SRC

but is incredibly useful.

* Lenses

We use it to supply the object at the top of the chain (~g~) in a
readable left-to-right way.

Because a record update returns a new record we can also use it to
chain updates.

#+BEGIN_SRC haskell
g & player1 . score .~ s1 & player2 . score .~ s2 & gameOver .~
True 
#+END_SRC

* Lenses

To write a lens like =name= ourselves we could have written a
getter and a setter then used the built-in =lens= function to
combine them.

#+BEGIN_SRC haskell
getName :: Player -> Text getName (Player { _name = n }) = n
setName :: Player -> Text -> Player setName p n = p { _name = n }
name :: Lens' Player Text name = lens getName setName 
#+END_SRC

* Lenses

But doing this for every field is a lot of boilerplate code --
typing with no real thought required.

As we'll see we can get tools to do for us.

*Demo:* ~Scrabble.Types~

* Lens operators

We are going to stick to a small number of the most basic lens
operators:

+----------------+-------+---------------------------------------------------+
| Operator       | Name  | Example                                           |
+----------------+-------+---------------------------------------------------+
| (^.)           | view  | g ^. word: gets word in g.                        |
+----------------+-------+---------------------------------------------------+
| (.~)           | set   | g & word .~ "HELLO": sets the word of g to        |
|                |       | "HELLO".                                          |
+----------------+-------+---------------------------------------------------+
| (%~)           | over  | g & word %~ T.toUpper: applies T.toUpper to       |
|                |       | the word.                                         |
+----------------+-------+---------------------------------------------------+
| (&)            | apply | Reverse application, used for supplying the       |
|                |       | first record to a composed lens, and for chaining |
|                |       | operations.                                       |
+----------------+-------+---------------------------------------------------+

* Creating a game

To start a fresh game we need to create a full bag then two players,
each with a rack that has been filled with tiles taken at "random"
from the bag.

Then the two players and the depleted bag are added to the game
state.

*Demo:* ~Scrabble.Bag~

* Randomness

For the randomness, we are going to use a pseudo-random number
generator (PRNGs).

These are completely deterministic (i.e. non-random) data
structures.

They are created using a \emph{seed}, and can produce a stream of
values whose sequence is hard enough for humans to predict that it
appears to be truly random.

But there's nothing magical happening -- PRNGs created with the same
seed return the same stream of values, and ones in the same state
(i.e. in the same position in its stream of values) returns the same
value next.

* Randomness

Every time we use the PRNG it returns the latest value and an
updated version of itself, primed to return the next value.

So our function that fills a rack needs to take a rack to be filled,
a bag to fill the rack from and a PRNG as parameters, and return a
triple of the filled rack, the depleted bag and, crucially, the
updated PRNG.

The type for PRNGs that we'll be using is ~StdGen~.

*Demo:* ~Scrabble.Bag~ and ~fillRack~.

* Starting a game

When we start a game we need to begin with a new ~StdGen~.
We can get one created with a seed based on the system time using
~getStdGen~ then keep updating it throughout the game.

Because we don't want everything in our library to be polluted with
~IO~ we leave the call to ~getStdGen~ to clients and presume they
can supply one to the ~newGame~ function.

*Demo:* ~Scrabble.Game~ and ~newGame~.

* Testing

Our tests now need to involve ~IO~.

*Demo:* ~Test.Chapter2~.

* Exercises

Have a go at the exercises at the end of chapter 2.

* Validating moves

We're now going to introduce a change that will have a big influence
on the internal design of the library:

*monadic error checking*

It will allow us to thread the state of the game through a long and
growing series of computations without having to worry at each stage
about whether anything went wrong.

(This code is the branch =chapter3=.)

* Validating moves

Now that we can place words onto the board, we want to check whether
doing so is valid. The rules about word placement are as follows:

+ Words are at least two letters long.
+ Words must be actually on the board.
+ A word must be continuous and either horizontal or vertical.
+ The first word must cross the centre square, while subsequent words
  must connect with an existing word.
+ The word and all additional words that it generates must be in the
  dictionary.

* Validating moves

Let's start by checking that word is actually on the board.

One approach would simply be to return =True= if each element of
a =WordPut= is on the board:

#+BEGIN_SRC haskell
-- | Check that a WordPut is on the board.
wordOnBoard :: WordPut -> Bool
wordOnBoard w = all (onBoard . fst) w
#+END_SRC

* Validating moves

There are lots of ways in which a move might be invalid.

We'd like to be able to let the user know exactly what went wrong.

If we carry on with validation checks that return true or false we
will need lots of =if= statements that work out what to report back to
the user.

* Validating moves

A common solution to writing a function that can fail is to use the
type =Either Text a=.

Values of this type are either =Left e=, where =e= is an error
message, or =Right x= where =x= is any type.

In the case of =straight=, if it returns any kind of =Right= value
then we know things went well.

So there's no need to return a =Bool=, we can just return =Left e= for
an error or =Right ()= if things went well.

* Validating moves

#+BEGIN_SRC haskell
-- in Scrabble.Board.Validation
-- | Check that a WordPut is on the board.
wordOnBoard :: WordPut -> Either Text ()
wordOnBoard w = if all (onBoard . fst) w
                 then Right ()
                 else Left "Word not on board"
#+END_SRC

* Validating moves

So, we write similar functions that validate other properties of a
move. 

Each of these function calls will return an =Either Text a=.

We find ourselves doing /a lot/ of case statements and pattern matching
on =Either= values.

* Validating moves

#+BEGIN_SRC haskell
-- in Scrabble.Board.Validation

validateMove :: Board   -- ^ The board
             -> Player  -- ^ The player making the move
             -> WordPut -- ^ The word to play
             -> Bool    -- ^ Is first move
             -> Either String Bool
validateMove b p w fm = 
    case wordOnBoard w of
      Right _ -> case connects w b fm of
                   Right _ -> case straight w of
                                Right _ -> case firstMoveTouchesCentre w fm of
                                             Right _ -> case lettersAvailable w p b of
                                                          Right -> Right ()
                                                          Left e -> Left e
                                             Left e -> Left e
                                Left e -> Left e
                   Left e -> Left e
      Left e -> Left e
#+END_SRC

* Validating moves
 
The technical term for this kind of code is *nasty*.

Such a deeply nested and indented structure is

+ hard to read,
+ hard to maintain and
+ hard to extend.


Fortunately, what we can do here is to use a *monad* to encapsulate the
checks for =Left= and =Right=.

* Validating moves

We make our =Either= type into a monad.

The monad instance says what to do when we encounter a =Left=
value, and then when we use the monad we can carry on as if everything
is a =Right= value -- no more case statements.

* Validating moves

We create a new type for arbitrary "evaluations" in the game, called
=Evaluator=. 

#+BEGIN_SRC haskell
-- in Scrabble.Types

newtype Evaluator a = Ev (Either Text a)
#+END_SRC

* Validating moves

This type wraps up an =Either Text a= type where the =Text= is an
error message and the =a= value is whatever is being evaluated.

For instance, =a= could be =()= in cases where moves are being checked
for validity, or =Game= when a function either fails or returns an
updated version of the game, or =Int= when a function either fails or
calculates the score of a word.

A value of the type =Evaluator Int= would be something like
=Ev (Left "Something went wrong.")= or =Ev (Right 42)=.

* Validating moves

Now we need to make a monad instance for =Evaluator=.

That requires us to first define the =Functor= and =Applicative=
instances, since every monad is an applicative and every applicative
is a functor.

The spirit of these definitions is that if we are dealing with an
=Ev (Left _)= value we want to **stop what we are doing and report the
error**.

When we are dealing with a =Ev (Right _)= value we can
**keep going**.

* Validating moves

#+BEGIN_SRC haskell
-- in Scrabble.Evaluator

instance Functor Evaluator where
  -- fmap :: (a -> b) -> f a -> f b 
  fmap _ (Ev (Left e))  = Ev (Left e)      -- report the error
  fmap f (Ev (Right g)) = Ev (Right (f g)) -- keep going
#+END_SRC

* Validating moves

#+BEGIN_SRC haskell
instance Applicative Evaluator where
  -- pure :: a -> f a
  pure k = Ev (Right k)
  -- (<*>) :: f (a -> b) -> f a -> f b
  Ev (Left  e)  <*>  _  =  Ev (Left e) -- report the error
  Ev (Right f)  <*>  r  =  fmap f r    -- keep going
#+END_SRC

* Validating moves

#+BEGIN_SRC haskell
instance Monad Evaluator where
    (Ev ev) >>= k =
        case ev of
          Left msg -> Ev (Left msg) -- report the error
          Right v  -> k v           -- keep going
    return   = pure
    fail msg = Ev (Left (T.pack msg))
#+END_SRC

* Validating moves

Now we need to rewrite all of the functions that returned =Either Text a=
to return =Evaluator a=.

The ones we have seen so far tested a boolean condition, =b=, and
returned =Right ()= if =b= succeeded or =Left Text= if =b= failed.

* Validating moves

We can make an abstraction for this pattern.

#+BEGIN_SRC haskell
-- in Scrabble.Evaluator

evalBool :: Bool -> Text -> Evaluator ()
evalBool b e = if b then pure () else fail (T.unpack e)
#+END_SRC

* Validating moves

Now we can write neat versions of all our validation functions:

#+BEGIN_SRC haskell
wordOnBoard :: WordPut -> Evaluator ()
wordOnBoard w = all (onBoard . fst) w `evalBool` "Word not on board"
#+END_SRC

* Validating moves

Monadic style allows us to remove all those case statments and write
=validateMove= in a far nicer style.

In effect, the case statements are all replaced by the one in the
definition of the monad instance. If any of the validation functions
encounters an error, the appropriate message is delivered.

* Validating moves

#+BEGIN_SRC haskell
validateMove :: Board   -- ^ The board
             -> Player  -- ^ The player making the move
             -> WordPut -- ^ The word to play
             -> Bool    -- ^ Is first move
             -> Evaluator ()
validateMove b p w fm =
	   wordOnBoard w
	   >> connects w b fm 
	   >> straight w 
	   >> firstMoveTouchesCentre w fm 
	   >> lettersAvailable w p b
#+END_SRC


* Tests

The tests from chapters one and two are refactored to work with the
=Evaluator= type.

We add a series of tests relating to validating words in
=Test.Chapter3=.

At this stage the tests start to look more complex.

This is because when we call functions in the =Evaluator= monad we
have to unwrap the result by pattern matching.

*Demo: prop_wordOnBoard*

* Exercises

+ Refactor the =straight= validator into two parts -- one called
  =straight= that checks the tiles are placed horizontally or vertically, and
  one called =continuous= that checks whether there are any gaps in the
  something goes wrong.
+ Change the tests so that if a =Left= value is returned you make sure the right
  error message is being received.
 


